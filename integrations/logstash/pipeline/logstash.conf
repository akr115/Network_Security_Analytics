input {
  beats {
    port => 6000
  }
}

filter {
  # Extract only the `decoded.csv` array from the incoming event
  mutate {
    rename => { "[decoded][csv]" => "[csv]" }
    remove_field => [
      "@version",
      "@timestamp",
      "agent",
      "ecs",
      "event",
      "host",
      "input",
      "log",
      "message",
      "tags",
      "decoded"
    ]
  }

  # Drop events that do not have exactly 82 fields
  ruby {
    code => "
      if event.get('csv').nil? || event.get('csv').length != 82
        event.cancel
      end
    "
  }

    ruby {
    code => "event.set('csv_json', event.get('csv').to_json)"
    }

    http {
    url => "http://predictor_api:8000/predict/csv"
    verb => "POST"
    body_format => "json"
    body => '{"csv": %{csv_json}}'
    headers => {
        "Content-Type" => "application/json"
    }
    target_body => "prediction_result"
    }

  # Extract prediction from the response
  mutate {
    add_field => { "prediction" => "%{[prediction_result][prediction]}" }
    remove_field => ["prediction_result"]
  }

  mutate {
    remove_field => ["csv_json"]
  }
}

output {
  # Send enriched event to Elasticsearch
  elasticsearch {
    hosts => ["http://elasticsearch:9200"]
    index => "network-predictions"
  }

  # Optional: debug output
#   stdout {
#     codec => rubydebug
#   }
}
